# Chapter 04. 채널 부호화 및 오류 제어

## 4.1 소개

- 무선 통신에서 채널 부호화와 오류 제어가 필요한 이유?

  - 육상 무선 통신의 경우 다중 경로 페이딩과 매우 낮은 신호 대 잡음비에 의하여 매우 취약한 전송 조건이 형성됨
  - 위성통신의 경우는 down link에서의 제한된 전력으로 인해 신호 품질이 취약해짐
  - 셀룰러 무선 통신 시스템에서 메시지는 BS와 MS 사이의 잡음이 섞인 매체를 통하여 전달되며 반사, 회절, 산란 등의 현상이 신호의 품질을 떨어뜨림

- 채널 부호화 : 송신국에서 원래의 메시지에 이 메시지와 미리 정해진 논리적 연관성을 가진 부가 정보를 추가하는 것

  → 전송이 되면 수신기는 채널 중에서 열화된 부호화된 신호를 수신한다.

  → 수신기는 본래의 정보와 부가 정보 간의 논리적인 상호관계를 활용하여 열화된 신호를 복원함으로 원본 메시지를 찾아낼 가능성을 크게 높임

  → 부가 정보를 도입하는 것은 전송과정에서 보다 많은 주파수 대역을 사용하게 됨

## 4.2 선형 블록 부호

- 선형 블록 부호(linear block code)에서 전송되는 정보열은 항상 미리 선정된 길이 k의 배수이다. 그렇지 않으면 필요한 만큼의 0을 정보열의 뒤에 붙여서 정보열의 길이가 k의 배수가 되도록 만듬

- 각각의 k비트는 (*n,k*) 선형 블록 코드에서 *n* 비트의 부호로 부호화 됨

- (*n, k*) 부호에는 2^n 개의 서로 다른 조합의 부호들이 존재함

- 예) (8, 6) 부호, 부호블록의 길이 n=8, 메시지 길이 k=6, 패리티 길이 n - k = 2

- 신드롬 벡터 : 0이 아닌 s 값을 얻게 되면, 오류가 생긴 것으로 간주함
  $$
  신드롬\,벡터\,:s=xH^T\\
  \mbox{생성 행렬 : }G=[I_k|P]_{k\times n}\\
  \mbox{패리티 검사 행렬 : }H=[P^TI_{n-k}]
  $$

## 4.3 순환 부호

- 선형 블록 부호의 종속 부류

  - 보다 실용적인 구현이 가능한 순환 구조를 가짐
  - 부호화가 쉽다

- n 비트의 부호어는 다음과 같이 다항식으로 표현될 수 있음
  $$
  c(x)=m(x)x^{n-k}+c_p(x)\\
  c_p(x)=rem[{m(x)x^{n-k}\over g(x)}]\\
  s(x)=rem[{c(x)+e(x)\over g(x)}]
  $$

## 4.4 순환 덧붙임 검사(CRC: cyclic redundancy check)

- 데이터 통신 및 기타 직렬 데이터 전송시스템에서 쓰이는 오류 검사 부호
- 송신기는 각각의 프레임마다 여분의 *n*비트 수열을 추가
  - 추가된 비트 수열을 프레임 검사 수열(FCS)라고 함
  - FCS에는 수신한 프레임에서의 오류를 검출하는 여분의 정보를 담고 있음

- CRC 알고리즘
  $$
  Q\,-\,k\mbox{비트 길이의 전송 프레임}\\
  F\,-\,Q\mbox{에 추가될 }n-k\mbox{ 비트의 FCS}\\
  J\,-\,Q\,와\,F\mbox{를 연결하여서 만든 수열}\\
  P\,-\,CRC\mbox{ 생성 다항식}\\
  J=Q\cdot x^{n-k}+F
  $$

## 4.5 길쌈 부호(Convolutional code)

- 실제 통신 환경에서 가장 많이 사용되는 채널 부호 중의 하나임

  - 주로 실시간 오류 수정에 사용

- $$
  r={k\over n}\\
  r:\mbox{Convolutional code의 부호화율}\\
  k:\mbox{병렬 입력 정보의 비트 수}\\
  n:\mbox{병렬 출력 부호의 비트 수}
  $$

- 길쌈 부호에는 **경판정**과 **연판정** 알고리즘이라는 두 가지의 복호화 방법이 있음
  - 경판정 복호화 : 수신 채널 값에 따라 단일 비트 양자화를 사용
  - 연판정 복호화 : 수신 채널 값에 따라 복수 비트 양자화를 사용 

## 4.6 인터리버

- 연집 오류로부터 데이터를 보호하는 것이 인터리빙의 목적
  - 연집 오류를 전체 부호어에 랜덤하게 분산하여 채널 부호화에 의한 오류 정정 성능을 높이기 위한 것
  - 블록 인터리버,  순환 인터리버, 반랜덤 인터리버 등이 있음
- 연집 오류가 여러 개의 단일 오류로 변경됨
  - 오류 정정 부호의 성능
    - 연집 오류 정정 <<< 단일 오류 정정
- 블록 인터리버의 기본 개념
  - 위에서 아래로 **열 방향으로 쓰고**, 좌에서 우로 **행 방향으로 읽는 것**

## 4.7 터보 부호

- 두 개의 동일한 RSC(Recursive Systematic Convolutional) 부호로 구성됨
- 부호화기
  - 첫 번째 부호기는 들어온 형태 그대로의 비트열 사용
  - 두 번째 부호기는 인터리버를 통한 비트열을 사용
    - 랜덤화를 위함
  - 두 부호기가 만드는 비트들의 상관 관계는 매우 낮음
- 복호화기
  - 두 개의 복호화기 중 하나를 복호화하여 일차적 추정치를 얻음
    - 이에 기반하여 더욱 정교한 추정치를 얻기 위함
  - 두 번째 복호화기의 추정치를 다시 첫째 복호화기의 입력으로 되입력함

## 4.8 ARQ 기법

- ARQ(automatic repeat request) : 자동 재전송 요청 기법으로 **데이터 통신**에서 사용되는 **오류 복구 방법의** 하나

- 수신기로부터 송신기에게 **ACK, NAK 신호**를 전송함으로 활용

- 대표적인 ARQ 방식 3가지

  - SAW ARQ(Stop-and-Wait ARQ)
  - GBN ARQ(Go-Back-N ARQ)
  - SR ARQ(Selective-Repeat ARQ)

  ### 4.8.1 SAW ARQ

  - 송신기가 한 번에 하나의 패킷을 보내면 수신기는 패킷을 받아서 오류가 없는지 살핌. 만일 오류가 없으면 수신기는 ACK 패킷을 보내고, 그렇지 않으면 NAK 패킷을 보냄. NAK을 받으면 재전송

  ### 4.8.2 GNB ARQ

  - SAW ARQ는 송신기가 수신기로부터 ACK을 받을 때까지 다음 패킷을 전송하지 못하기 때문에 통신 채널을 잘 활용하지 못하는 단점이 있음
  - GBN ARQ는 송신기가 앞서 보낸 패킷들에 대한 ACK을 기다리지 않고 여러 개의 패킷을 전송. 전송 중에 어느 패킷에 오류가 발생하여 수신기로부터 NAK를 받으면 송신기는 오류가 난 패킷 이후의 패킷들을 모두 재전송
  - GBN ARQ는 패킷 전송 중에 연집 오류의 확률이 높은 경우 적합

  ### 4.8.3 SR ARQ

  - GBN ARQ 방식은 하나의 패킷 오류라도 불필요할 수 있는 여러 패킷의 재전송을 유발
  - 수신기는 오류 없이 수신된 모든 패킷에 대하여 ACK로 응답하고, 송신기는 ACK가 오지 않는 패킷을 발견할 경우, 분실되었거나 오류가 난 것으로 간주하여 그 패킷만을 재전송함으로 불필요한 재전송을 없애줌
  - SR ARQ 프로토콜의 구현이 다른 두 프로토콜보다 더 복잡하지만 가장 효율이 좋음
  - 패킷 오류나 손실 확률이 작은 경우에는 SR ARQ 방식이 오류가 난 패킷만을 보내기 때문에 장점이 큼
